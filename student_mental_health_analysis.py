# -*- coding: utf-8 -*-
"""student-mental-health-analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TBFsPL_sut9Jl5VX4qJprgq11roTgmgz
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib_venn import venn3

from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import GridSearchCV, train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, accuracy_score, confusion_matrix
from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline

data = pd.read_csv('Student Mental health.csv')
data.head()

data.info()

data.columns = ['Timestamp', 'Gender', 'Age', 'Course', 'Year of Study', 'CGPA', 'Marital Status', 'Depression', 'Anxiety', 'Panic Attack', 'Treatment']

data.drop("Timestamp",axis=1,inplace=True)

data.head(0)

data.isnull().sum()

data.duplicated().any()

data.dropna(inplace=True)

numerical_cols = data.select_dtypes(include='number').columns
sns.boxplot(data=data[numerical_cols])
plt.show()

data['CGPA'] = data['CGPA'].str.strip()

def convert_cgpa_range(cgpa_range):
    cgpa_values = cgpa_range.split('-')
    midpoint = (float(cgpa_values[0]) + float(cgpa_values[1])) / 2
    return midpoint

data['CGPA'] = data['CGPA'].apply(convert_cgpa_range)
print(data['CGPA'].unique())

data['Year of Study'] = data['Year of Study'].str.lower().str.replace('year', '').str.strip().map({'1': 1, '2': 2, '3': 3, '4': 4})
print(data['Year of Study'].unique())

binary_columns = ['Marital Status','Depression', 'Anxiety', 'Panic Attack', 'Treatment']
data[binary_columns] = data[binary_columns].replace({'Yes': 1, 'No': 0})

data.head()

data['Course'].unique()

course_mapping = {
    'engineering': 'Engineering',
    'islamic education': 'Islamic Education',
    'bit': 'BIT',
    'laws': 'Law',
    'mathemathics': 'Mathematics',
    'pendidikan islam': 'Islamic Education',
    'bcs': 'BCS',
    'human resources': 'Human Resources',
    'irkhs': 'IRKHS',
    'psychology': 'Psychology',
    'kenms': 'KENMS',
    'accounting': 'Accounting',
    'enm': 'ENM',
    'marine science': 'Marine Science',
    'koe': 'KOE',
    'banking studies': 'Banking Studies',
    'business administration': 'Business Administration',
    'kirkhs': 'KIRKHS',
    'usuluddin': 'Usuluddin',
    'taasl': 'TAASL',
    'engine': 'Engineering',
    'ala': 'ALA',
    'biomedical science': 'Biomedical Science',
    'benl': 'BENL',
    'it': 'IT',
    'cts': 'CTS',
    'econs': 'Economics',
    'mhsc': 'MHSC',
    'malcom': 'MALCOM',
    'kop': 'KOP',
    'human sciences': 'Human Sciences',
    'biotechnology': 'Biotechnology',
    'communication': 'Communication',
    'diploma nursing': 'Diploma Nursing',
    'pendidikan islam': 'Islamic Education',
    'radiography': 'Radiography',
    'fiqh fatwa': 'Fiqh Fatwa',
    'diploma tesl': 'Diploma TESL',
    'fiqh': 'Fiqh',
    'nursing': 'Nursing',
}

data['Course'] = data['Course'].str.lower().str.strip().map(course_mapping)
data.Course.unique()

data['Gender'] = data['Gender'].map({'Female': 0, 'Male': 1})

label_encoder = LabelEncoder()
data['Course'] = label_encoder.fit_transform(data['Course'])

data.head()

"""**Exploratory Data Analysis**"""

correlation_matrix = data.corr()
plt.figure(figsize=(12, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='plasma', fmt='0.2f')
plt.title('Correlation Matrix')
plt.show()

data['CGPA'].unique()

columns_of_interest = ['Gender', 'Age', 'Marital Status', 'Depression', 'Anxiety', 'Panic Attack', 'Treatment']

for column in columns_of_interest:
    # Pie chart
    data_pie = data[column].value_counts()
    plt.figure(figsize=(8, 6))
    plt.pie(data_pie, labels=data_pie.index, autopct='%.0f%%', shadow=True, wedgeprops={"width": 0.3})
    plt.title(f'Distribution of {column}')
    plt.show()

    # Count plot
for column in columns_of_interest:
    plt.figure(figsize=(10, 6))
    sns.countplot(data=data, x=column, hue="CGPA", palette='pastel')
    plt.title(f'Countplot of {column} by CGPA')
    plt.xlabel(column)
    plt.ylabel('Count')
    plt.show()

depressed = data[(data["Depression"] == 1)]
anxious = data[(data["Anxiety"] == 1)]
panicking = data[(data["Panic Attack"] == 1)]

venn3(subsets = [set(depressed.index),
                 set(anxious.index),
                 set(panicking.index)],
      set_labels = ("Depressed", "Anxious", "Having Panic Attacks"),
      set_colors = ("Green", "Red", "Orange"),
      alpha = 0.878)

plt.title("Conditions", fontsize = 16)
plt.show()

"""**MACHINE LEARNING/ MODEL TRAINING**

RandomForest
"""

param_grid = {
    'n_estimators': [50],
    'max_depth': [10],
    'min_samples_split': [2],
    'min_samples_leaf': [5]
}

X = data.drop(['Depression'], axis=1)
y = data['Depression']

model = RandomForestClassifier(random_state=42)
grid_search = GridSearchCV(model, param_grid, cv=3, scoring='accuracy', n_jobs=-1)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
grid_search.fit(X_train, y_train)

best_params = grid_search.best_params_
print("Best Hyperparameters:", best_params)

best_model = grid_search.best_estimator_
y_pred = best_model.predict(X_test)

accuracy = accuracy_score(y_test, y_pred)

print(f"Accuracy: {accuracy:.2f}")

"""KNN

"""

param_grid_knn = {
    'knn__n_neighbors': [5],
    'knn__weights': ['uniform', 'distance'],
    'knn__p': [2]
}

X_train_knn, X_test_knn, y_train_knn, y_test_knn = train_test_split(X, y, test_size=0.2, random_state=42)

model_knn = KNeighborsClassifier()

pipeline = Pipeline([('scaler', StandardScaler()), ('knn', model_knn)])

grid_search_knn = GridSearchCV(pipeline, param_grid_knn, cv=3, scoring='accuracy', n_jobs=-1)
grid_search_knn.fit(X_train_knn, y_train_knn)

best_params_knn = grid_search_knn.best_params_
print("Best Hyperparameters for KNN:", best_params_knn)

best_model_knn = grid_search_knn.best_estimator_
y_pred_knn = best_model_knn.predict(X_test_knn)

accuracy_knn = accuracy_score(y_test_knn, y_pred_knn)

print(f"Accuracy for KNN: {accuracy_knn:.2f}")

import pickle

with open('model_knn.pkl', 'wb') as file:
    pickle.dump(model, file)